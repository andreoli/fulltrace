fulltrace
=========

A complete ftrace- and uprobes-based tracer (user, libraries, kernel) for GNU/Linux

fulltrace traces the execution of an ELF program, providing as output a full trace of its userspace, library and kernel function calls. This is achieved by analyzing the ELF structure of the user-provided executable to identify all the function included in its original code. Then, the focus of the inspection moves to the libraries used by the executable (the dynamic dependencies of the executable, those listed with `ldd`); fulltrace plants userspace debug probes (uprobe) on the address of these userspace symbols. The ftrace kernel subsystem is therefore notified when those symbols are encountered and is able to include them in a full function_graph trace.
In an attempt to restrict the tracing activity to the bare execution of the user-provided program, fulltrace encapsulates it in a wrapper, whose source is available along with the main full-trace.sh script.

Table of contents:

1. [Prerequisites](#prereq)
2. [Configuration](#config)
3. [Command-line interface](#cmdline)
4. [Usage examples](#usage)
5. [Output file](#output)
6. [Author](#author)

Prerequisites<a id="prereq"></a>
-------------

* fulltrace relies on a Linux kernel compiled with its built-in tracing subsystem (ftrace), the function\_graph tracer and transparent user-space probes. In more detail, the following kernel configuration options and their dependencies must be set as enabled (=y): FTRACE, TRACING\_SUPPORT, UPROBES, UPROBE\_EVENT, FUNCTION\_GRAPH\_TRACER.
* fulltrace also needs the `objdump`, `readelf` and `ldd` executables to be installed.
* As it is necessary to compile the wrapper program, the `gcc` compiler, the `ld` linker and the `make` utility must be available.

Configuration<a id="config"></a>
-------------

Before starting to use the full-trace.sh script, the wrapper program needs to be compiled. It is necessary that the user issues the following command inside the `/fulltrace` directory:  
`$ make`

Command-line interface<a id="cmdline"></a>
----------------------

In its full-trace.sh main script, fulltrace provides a straight-forward command-line interface to its features. Details about its usage can be printed by running it with its `-h` option.

<pre>
$ ./full-trace.sh -h
usage: ./full-trace.sh
&#9;[-b|--bufsize bufsize\] [-c|--clean] [-d|--debug] [-h|--help]
&#9;[-o|--output] [-t|--trace] [-u|--uprobes]
&#9;[-k|--ksubsys subsys1,...] -- <command> <arg>...

Full process tracer (userspace, libraries, kernel)
OPTIONS:
-b|--bufsize&#9;Set the per-cpu buffer size (KB)
-c|--clean&#9;Clean temporary files
-d|--debug&#9;Debug output
-h|--help&#9;This help
-o|--output&#9;Output decoding
-t|--trace&#9;Process tracing
-u|--uprobes&#9;Uprobes creation
-k|--ksubsys&#9;Enable traces for listed subsystems
</pre>

Usage examples<a id="usage"></a>
--------------

The user, to begin with, might want to obtain a trace from scratch; it is then necessary for the fulltrace script to perform the following steps:

1. analyze the executable and plant the userspace debug probes for all the symbols its execution involves;
2. trace the execution of the process;
3. decode the output trace to trim spurious uprobe events and substitute function names to the bare addresses of the symbol.

As explained by the usage help, this means passing the `-u` (uprobes creation), `-t` (process tracing) and `-o` (output decoding) options to the full-trace.sh script. Use the following command line to **obtain a full trace from scratch**.  
`$ ./full-trace.sh -uto -- <executable_name> [executable_arguments]`

The **output file** generated by fulltrace is stored in the `/tmp` folder; its name is `trace.decoded`. Note that every run of fulltrace overwrites the output file.

Use the following command line to **cleanup temporary files** stored by fulltrace in the `/tmp` folder, that may interfere with subsequent runs (the trace.decoded file will be preserved).  
`$ ./full-trace.sh -c`

The most time-expensive operation performed by fulltrace is the analysis of user-provided executable and needed libraries. This operation may be performed only once per session, if the user wants to re-use the same set of userspace probes. However, if the same uprobes set is used to trace two different programs, the program-specific functions of the second executable will not be included in the trace.  
This kind of usage is convenient when:

* the user doesn't care about program-specific functions, just wants a call trace of library functions, and both the programs use the same libraries;
* the user wants to trace the the execution of the same program more than once.

Use the following command line to **generate and plant uprobes** for a program.  
`$ ./full-trace.sh -u -- <executable_name> [executable_arguments]`  
This next command line will trace the execution of a program **using an already generated set of userspace probes**.  
`$ ./full-trace.sh -to -- <executable_name> [executable_arguments]`  

Output file<a id="output"></a>
-----------

The format of the output file is based on the classic function\_graph provided by ftrace, that shows a call graph of the traced functions. The ftrace kernel subsystem if configured by fulltrace to include, for each event:

* absolute timestamps (the funcgraph-abstime option);
* execution context of the event, that is the process/thread that originally issued the function call (the funcgraph-proc option);
* execution latency of kernel functions (as provided by the function\_graph tracer).

The basic ftrace output is improved by fulltrace to show, along with the execution latency of kernel functions, the duration of userspace and library functions.

Author<a id="author"></a>
------

Please address any bugreport or comment to the author:  
>Mauro Andreolini (<mauro.andreolini@unimore.it>)
